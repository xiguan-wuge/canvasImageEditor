<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="viewport" content="width=device-width, initial-scale=1.0" />
	<meta charset="UTF-8" />
	<title>Canvas Drawing App with Multiple Features</title>
	<style>
		#toolbar {
			margin-bottom: 10px;
		}

		#mosaicCanvas {
			border: 1px solid black;
			cursor: crosshair;
		}

		.button {
			margin-right: 10px;
			padding: 5px 10px;
			cursor: pointer;
			background-color: lightgray;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.button.active {
			background-color: #4caf50;
			color: white;
		}
	</style>
</head>

<body>
	<div id="toolbar">
		<button class="button" id="drawArrowBtn">画箭头</button>
		<button class="button" id="mosaicBtn">添加马赛克</button>
		<button class="button" id="drawScribbleBtn">涂鸦</button>
		<button class="button" id="eraser">橡皮擦</button>
		<button class="button" id="textInputBtn">文本输入</button>
		<button class="button" id="rectBtn">矩形</button>
		<button class="button" id="circleBtn">圆</button>
		<button class="button" id="downloadBtn">下载</button>
		<button class="button" id="undoBtn">撤销</button>
		<button class="button" id="redoBtn">取消撤销</button>

		<!-- 字体和颜色选择 -->
		<select id="fontSizeSelect">
			<option value="20px">20px</option>
			<option value="24px">24px</option>
			<option value="28px">28px</option>
			<!-- Add more sizes as needed -->
		</select>

		<input type="color" id="fontColorPicker" value="#000000" />
		<input type="number" id="strokeWidth" value="4" />
	</div>
	<div class="canvas-wrapper" style="position: relative;width: 800px;height: 600px;">
		<canvas id="mosaicCanvas" width="800" height="600" style="position: absolute;top: 0;left: 0;"></canvas>
		<canvas id="mosaicCanvas2" width="800" height="600"></canvas>
	</div>
	<script>
		const canvas = document.getElementById('mosaicCanvas');
		const canvas2 = document.getElementById('mosaicCanvas2');
		// 启用 willReadFrequently 属性
		const ctx = canvas.getContext('2d', { willReadFrequently: true });
		const ctx2 = canvas2.getContext('2d', { willReadFrequently: true });

		let isDrawing = false;
		let startX, startY;
		let currentTool = 'arrow'; // 默认工具为画箭头
		const actions = []; // 用于存储操作的历史记录
		let undoStack = []; // 用于存储撤销的操作
		let textElements = []; // 用于存储文本元素及其位置信息
		let rectangles = []; // 存储所有矩形信息
		let ellipses = []; // 存储所有圆/椭圆信息
		let selectedEllipse = null; // 当前被选中的圆
		let newEllipse = null; // 新创建的圆
		let canvasWidth = ctx.width;
		let canvasHeight = ctx.height;

		const imageSrc =
			'https://cdn.pixabay.com/photo/2024/01/02/10/33/stream-8482939_1280.jpg'; // 替换为你要使用的图片路径
		const img = new Image();
		img.crossOrigin = 'Anonymous'; // 允许跨域访问
		img.src = imageSrc;

		img.onload = function () {
			ctx2.drawImage(img, 0, 0, canvas.width, canvas.height);
			// saveAction(); // 保存初始状态
		};

		// 工具按钮设置
		const arrowButton = document.getElementById('drawArrowBtn');
		const mosaicButton = document.getElementById('mosaicBtn');
		const scribbleButton = document.getElementById('drawScribbleBtn');
		const eraserButton = document.getElementById('eraser');
		const textInputButton = document.getElementById('textInputBtn');
		const rectButton = document.getElementById('rectBtn');
		const circleButton = document.getElementById('circleBtn');
		const undoButton = document.getElementById('undoBtn');
		const redoButton = document.getElementById('redoBtn');
		const downloadButton = document.getElementById('downloadBtn');

		arrowButton.addEventListener('click', () => setTool('arrow'));
		mosaicButton.addEventListener('click', () => setTool('mosaic'));
		scribbleButton.addEventListener('click', () => setTool('scribble'));
		eraserButton.addEventListener('click', () => setTool('eraser'));
		textInputButton.addEventListener('click', () => setTool('text'));
		rectButton.addEventListener('click', () => setTool('rect'));
		circleButton.addEventListener('click', () => setTool('circle'));
		undoButton.addEventListener('click', undo);
		redoButton.addEventListener('click', redo);
		downloadButton.addEventListener('click', handleDownload);

		function setTool(tool) {
			currentTool = tool;
			console.log('currentTool', tool);
			arrowButton.classList.toggle('active', tool === 'arrow');
			mosaicButton.classList.toggle('active', tool === 'mosaic');
			scribbleButton.classList.toggle('active', tool === 'scribble');
			eraserButton.classList.toggle('active', tool === 'eraser');
			textInputButton.classList.toggle('active', tool === 'text');
			rectButton.classList.toggle('active', tool === 'rect');
			circleButton.classList.toggle('active', tool === 'circle');
		}

		function saveAction() {
			const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
			actions.push(imageData);
			undoStack = []; // 每次新的操作会清空撤销栈
		}

		function undo() {
			if (actions.length > 1) {
				const lastAction = actions.pop();
				undoStack.push(lastAction);
				ctx.putImageData(actions[actions.length - 1], 0, 0);
			}
		}

		function redo() {
			if (undoStack.length > 0) {
				const redoAction = undoStack.pop();
				actions.push(redoAction);
				ctx.putImageData(redoAction, 0, 0);
			}
		}

		document.addEventListener('DOMContentLoaded', () => {
			canvasWidth = canvas.width;
			canvasHeight = canvas.height;
			console.log('canvasWidth', canvasWidth);
			console.log('canvasHeight', canvasHeight);
		});
		canvas.addEventListener('mousedown', function (e) {
			ctx.globalCompositeOperation = 'source-over';
			isDrawing = true;
			startX = e.offsetX;
			startY = e.offsetY;
			console.log('mousedown', currentTool);
			if (currentTool === 'text') {
				let elementToEdit = null;

				for (const element of textElements) {
					const width = ctx.measureText(element.input.value).width;
					const height = parseInt(element.fontSize, 10);
					if (
						startX >= element.x &&
						startX <= element.x + width &&
						startY >= element.y - height &&
						startY <= element.y
					) {
						elementToEdit = element;
						break;
					}
				}

				if (elementToEdit) {
					createTextInput(
						elementToEdit.x - canvas.offsetLeft,
						elementToEdit.y -
						parseInt(elementToEdit.fontSize, 10) -
						canvas.offsetTop,
						elementToEdit
					);
				} else {
					createTextInput(startX, startY);
				}
				// const text = prompt("请输入文本内容：", "");
				// if (text) {
				//     ctx.font = "20px Arial";
				//     ctx.fillStyle = "black";
				//     ctx.fillText(text, startX, startY);
				//     saveAction();
				// }
				// createTextInput(startX, startY);
				isDrawing = false; // 结束文本输入操作
			} else if (currentTool === 'rect') {
				handleRect(startX, startY);
			} else if (currentTool === 'circle') {
				console.log('circle---');
				selectedEllipse = null;
				newEllipse = null;
				// handleCircle(startX, startY)
				// 检查是否点击了已有的圆/椭圆
				for (const ellipse of ellipses) {
					if (isPointInEllipse(startX, startY, ellipse)) {
						selectedEllipse = ellipse;
						break;
					}
				}

				if (selectedEllipse) {
					// 选择圆/椭圆并允许拖动或调整半径
					// dragEllipse(selectedEllipse, startX, startY);
				} else {
					// 开始绘制新圆/椭圆
					newEllipse = {
						x: startX,
						y: startY,
						radiusX: 0,
						radiusY: 0,
						color: document.getElementById('fontColorPicker').value,
						strokeWidth: parseInt(document.getElementById('strokeWidth').value) || 2
					};
					ellipses.push(newEllipse);
				}
			}
		});

		canvas.addEventListener('mousemove', function (e) {
			if (!isDrawing) return;

			const currentX = e.offsetX;
			const currentY = e.offsetY;

			if (currentTool === 'arrow') {
				drawArrow(startX, startY, currentX, currentY);
				// drawGradientArrow(ctx,startX, startY, currentX, currentY);
			} else if (currentTool === 'mosaic') {
				applyMosaicAt(currentX, currentY);
			} else if (currentTool === 'scribble') {
				drawScribble(currentX, currentY);
			} else if (currentTool === 'eraser') {
				drawEraser(currentX, currentY);
			} else if (currentTool === 'circle') {
				ctx.clearRect(0, 0, canvasWidth, canvasHeight); // 清除画布
				if (newEllipse) {
					const newRadiusX = Math.abs(currentX - newEllipse.x);
					const newRadiusY = Math.abs(currentY - newEllipse.y);

					newEllipse.radiusX = newRadiusX;
					newEllipse.radiusY = newRadiusY;

					// redrawCanvas();
					drawEllipse(
						newEllipse.x,
						newEllipse.y,
						newEllipse.radiusX,
						newEllipse.radiusY,
						newEllipse.color,
						newEllipse.strokeWidth
					);
				} else if (selectedEllipse) {
					// const selectX = currentX - selectedEllipse.x;
					// const selectY = currentY - selectedEllipse.y;

					// selectedEllipse.x = selectX;
					// selectedEllipse.y = selectY;
					selectedEllipse.x = currentX;
					selectedEllipse.y = currentY;

					drawEllipse(
						selectedEllipse.x,
						selectedEllipse.y,
						selectedEllipse.radiusX,
						selectedEllipse.radiusY,
						selectedEllipse.color,
						selectedEllipse.strokeWidth
					);
				}
			}
		});

		canvas.addEventListener('mouseup', function () {
			if (isDrawing) {
				isDrawing = false;
				saveAction(); // 保存当前操作
			}
		});

		canvas.addEventListener('mouseleave', function () {
			if (isDrawing) {
				isDrawing = false;
				saveAction(); // 保存当前操作
			}
		});

		function drawArrow(x1, y1, x2, y2) {
			// 清除并恢复上次绘制的图像
			// ctx.putImageData(actions[actions.length - 1], 0, 0);

			// 箭头头部的长度
			const headlen = 10;
			const angle = Math.atan2(y2 - y1, x2 - x1);

			// 计算距离
			const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

			// 线条的最大宽度
			const maxLineWidth = 10;

			// 逐段绘制线条，使其逐渐变粗
			for (let i = 0; i < distance; i++) {
				const t = i / distance;
				const lineWidth = 1 + t * (maxLineWidth - 1); // 线条宽度从1逐渐增至maxLineWidth
				const xPos = x1 + t * (x2 - x1);
				const yPos = y1 + t * (y2 - y1);

				ctx.beginPath();
				ctx.moveTo(xPos, yPos);
				ctx.lineTo(xPos + 1, yPos + 1); // 绘制短小的线段
				ctx.lineWidth = lineWidth;
				ctx.strokeStyle = 'red';
				ctx.stroke();
			}

			// 绘制箭头头部
			ctx.beginPath();
			ctx.moveTo(x2, y2);
			ctx.lineTo(
				x2 - headlen * Math.cos(angle - Math.PI / 6),
				y2 - headlen * Math.sin(angle - Math.PI / 6)
			);
			ctx.lineTo(
				x2 - headlen * Math.cos(angle + Math.PI / 6),
				y2 - headlen * Math.sin(angle + Math.PI / 6)
			);
			ctx.lineTo(x2, y2);
			ctx.lineTo(
				x2 - headlen * Math.cos(angle - Math.PI / 6),
				y2 - headlen * Math.sin(angle - Math.PI / 6)
			);
			ctx.strokeStyle = 'red';
			ctx.lineWidth = 1; // 箭头头部的线宽可以保持统一
			ctx.stroke();
			ctx.fillStyle = 'red';
			ctx.fill();
		}
		// 绘制渐变线条的箭头
		function drawGradientArrow(ctx, fromX, fromY, toX, toY, startWidth = 1, endWidth = 8) {
			// if(actions.length) {
			// 	ctx.putImageData(actions[actions.length - 1], 0, 0);
			// }
			ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除画布
			const steps = 300; // 分段数量
			const dx = (toX - fromX) / steps;
			const dy = (toY - fromY) / steps;

			ctx.lineCap = 'round'; // 设置线条端点为圆形

			for (let i = 0; i < steps; i++) {
				const x1 = fromX + i * dx;
				const y1 = fromY + i * dy;
				const x2 = fromX + (i + 1) * dx;
				const y2 = fromY + (i + 1) * dy;

				const lineWidth = startWidth + (endWidth - startWidth) * (i / steps);

				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.strokeStyle = '#FF0000';
				ctx.lineWidth = lineWidth;
				ctx.stroke();
			}

			const angle = Math.atan2(toY - fromY, toX - fromX);
			const headLength = endWidth * 2;

			ctx.beginPath();
			ctx.moveTo(toX, toY);
			ctx.lineTo(
				toX - headLength * Math.cos(angle - Math.PI / 6),
				toY - headLength * Math.sin(angle - Math.PI / 6)
			);
			ctx.lineTo(
				toX - headLength * Math.cos(angle + Math.PI / 6),
				toY - headLength * Math.sin(angle + Math.PI / 6)
			);
			ctx.lineTo(toX, toY);
			ctx.lineTo(
				toX - headLength * Math.cos(angle - Math.PI / 6),
				toY - headLength * Math.sin(angle - Math.PI / 6)
			);
			ctx.strokeStyle = '#FF0000';
			ctx.lineWidth = endWidth;
			ctx.stroke();
			ctx.fillStyle = '#FF0000';
			ctx.fill();
		}

		// 马赛克
		function applyMosaicAt(x, y) {
			const blockSize = 20; // 马赛克块大小

			const startX = Math.max(0, x - blockSize / 2);
			const startY = Math.max(0, y - blockSize / 2);
			const width = Math.min(blockSize, canvas.width - startX);
			const height = Math.min(blockSize, canvas.height - startY);

			const imageData = ctx.getImageData(startX, startY, width, height);
			const data = imageData.data;

			let red = 0,
				green = 0,
				blue = 0;
			let pixelCount = 0;

			for (let row = 0; row < height; row++) {
				for (let col = 0; col < width; col++) {
					const index = (row * width + col) * 4;
					red += data[index];
					green += data[index + 1];
					blue += data[index + 2];
					pixelCount++;
				}
			}

			red = Math.floor(red / pixelCount);
			green = Math.floor(green / pixelCount);
			blue = Math.floor(blue / pixelCount);

			for (let row = 0; row < height; row++) {
				for (let col = 0; col < width; col++) {
					const index = (row * width + col) * 4;
					data[index] = red;
					data[index + 1] = green;
					data[index + 2] = blue;
				}
			}

			ctx.putImageData(imageData, startX, startY);
		}

		// 涂鸦功能
		function drawScribble(x, y) {
			ctx.beginPath(); // 开始新的路径
			ctx.arc(x, y, 2, 0, Math.PI * 2); // 以当前点为中心绘制一个小圆点
			ctx.fillStyle = 'black';
			ctx.globalCompositeOperation = 'source-over';
			ctx.fill();
			ctx.closePath(); // 结束路径
		}
		// 橡皮擦功能
		function drawEraser(x, y) {
			console.log('drawEraser');
			ctx.beginPath(); // 开始新的路径
			ctx.arc(x, y, 2, 0, Math.PI * 2); // 以当前点为中心绘制一个小圆点
			ctx.strokeStyle = '#fff';
			ctx.fill();
			ctx.globalCompositeOperation = 'destination-out';
			ctx.closePath(); // 结束路径
		}

		// 创建文本输入框
		function createTextInput(x, y, existingElement = null) {
			console.log('createTextInput', x, y, existingElement);
			let input;

			if (existingElement) {
				input = existingElement.input;
				input.style.pointerEvents = 'auto';
				input.style.zIndex = 1000;
				input.focus();
			} else {
				input = document.createElement('input');
				input.type = 'text';
				input.style.position = 'absolute';
				input.style.left = `${x + canvas.offsetLeft}px`;
				input.style.top = `${y + canvas.offsetTop}px`;
				input.style.fontSize = document.getElementById('fontSizeSelect').value;
				input.style.color = document.getElementById('fontColorPicker').value;
				input.style.border = '1px solid black';
				input.style.background = 'transparent';
				input.style.zIndex = 1000;
				input.style.width = 'auto';

				document.body.appendChild(input);
				input.focus();

				// 动态调整输入框宽度
				input.addEventListener('input', () => {
					input.style.width = `${input.scrollWidth}px`;
				});

				input.addEventListener('blur', () => {
					const textValue = input.value.trim();

					if (textValue !== '') {
						const textElement = {
							input: input,
							x: x,
							y: y + parseInt(input.style.fontSize, 10),
							fontSize: input.style.fontSize,
							color: input.style.color
						};
						textElements.push(textElement);

						ctx.font = `${input.style.fontSize} Arial`;
						ctx.fillStyle = input.style.color;
						ctx.fillText(textValue, textElement.x, textElement.y);
						input.style.border = 'none';
						input.style.pointerEvents = 'none';
						input.style.zIndex = -1;
					} else {
						document.body.removeChild(input);
					}
					saveAction(); // 保存当前操作
				});

				input.addEventListener('keydown', function (e) {
					if (e.key === 'Enter') {
						input.blur(); // 模拟输入框失去焦点，触发绘制
					}
				});

				input.addEventListener('mousedown', function (e) {
					const offsetX = e.clientX - input.offsetLeft;
					const offsetY = e.clientY - input.offsetTop;

					function moveAt(event) {
						input.style.left = `${event.clientX - offsetX}px`;
						input.style.top = `${event.clientY - offsetY}px`;
					}

					document.addEventListener('mousemove', moveAt);

					document.addEventListener(
						'mouseup',
						function () {
							document.removeEventListener('mousemove', moveAt);
						},
						{ once: true }
					);
				});
			}
		}

		// 绘制矩形边框
		function drawRectangleBorder(x, y, width, height, color, strokeWidth) {
			ctx.lineWidth = strokeWidth || 2;
			ctx.strokeStyle = color || 'black';
			ctx.strokeRect(x, y, width, height);
		}

		// 检测点击是否在矩形内
		function isPointInRectangle(x, y, rect) {
			return (
				x >= rect.x &&
				x <= rect.x + rect.width &&
				y >= rect.y &&
				y <= rect.y + rect.height
			);
		}

		let canvasSnapshot;
		// 矩形的处理函数
		function handleRect(clickedX, clickedY) {
			let selectedRect = null;

			// 检查是否点击了已有的矩形
			for (const rect of rectangles) {
				if (isPointInRectangle(clickedX, clickedY, rect)) {
					selectedRect = rect;
					break;
				}
			}

			if (selectedRect) {
				// 选择矩形并允许拖动或调整大小
				dragRectangle(selectedRect, clickedX, clickedY);
			} else if (currentTool === 'rect') {
				// 保存当前画布状态
				canvasSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
				// 开始绘制新矩形
				const newRect = {
					x: clickedX,
					y: clickedY,
					width: 0,
					height: 0,
					color: document.getElementById('fontColorPicker').value,
					strokeWidth: parseInt(document.getElementById('strokeWidth').value) || 2
				};
				rectangles.push(newRect);

				// 绑定拖动事件来调整矩形大小
				function onMouseMove(event) {
					const newWidth = event.offsetX - newRect.x;
					const newHeight = event.offsetY - newRect.y;

					newRect.width = newWidth;
					newRect.height = newHeight;
					// // 重新绘制所有内容，避免残留上一次的矩形
					ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空画布
					// redrawLastFrame(); // 重新绘制最后一帧的内容
					// 恢复到保存的画布状态
					// ctx.putImageData(canvasSnapshot, 0, 0);

					drawRectangleBorder(
						newRect.x,
						newRect.y,
						newRect.width,
						newRect.height,
						newRect.color,
						newRect.strokeWidth
					);
				}
				document.addEventListener('mousemove', onMouseMove);

				// 释放鼠标时，停止绘制矩形
				function onMouseUp() {
					document.removeEventListener('mousemove', onMouseMove);
					document.removeEventListener('mouseup', onMouseUp);
					saveAction(); // 保存当前操作
				}
				document.addEventListener('mouseup', onMouseUp, { once: true });
			}
		}

		// 拖动矩形或调整大小
		function dragRectangle(rect, startX, startY) {
			const offsetX = startX - rect.x;
			const offsetY = startY - rect.y;
			function onMouseMove(event) {
				const newX = event.offsetX - offsetX;
				const newY = event.offsetY - offsetY;

				rect.x = newX;
				rect.y = newY;

				// redrawLastFrame();
				ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除画布
				console.log('rectangles', rectangles);
				rectangles.forEach((r) =>
					drawRectangleBorder(r.x, r.y, r.width, r.height, r.color, r.strokeWidth)
				);
			}
			function onMouseUp() {
				document.removeEventListener('mousemove', onMouseMove);
				document.removeEventListener('mouseup', onMouseUp);
				saveAction(); // 保存当前操作
			}
			document.addEventListener('mousemove', onMouseMove);

			document.addEventListener('mouseup', onMouseUp, { once: true });
		}

		function redrawLastFrame() {
			// 重绘所有矩形边框
			rectangles.forEach((rect) => {
				drawRectangleBorder(
					rect.x,
					rect.y,
					rect.width,
					rect.height,
					rect.color,
					rect.strokeWidth
				);
			});

			// 重绘所有其他内容，如箭头、文本、涂鸦等
			// arrows.forEach(arrow => {
			//     drawArrow(arrow.startX, arrow.startY, arrow.endX, arrow.endY, arrow.lineWidth, arrow.color);
			// });

			// textElements.forEach(element => {
			//     ctx.font = `${element.input.style.fontSize} Arial`;
			//     ctx.fillStyle = element.input.style.color;
			//     ctx.fillText(element.input.value, element.x, element.y);
			// });

			// doodles.forEach(path => {
			//     ctx.beginPath();
			//     ctx.moveTo(path[0].x, path[0].y);
			//     for (let i = 1; i < path.length; i++) {
			//         ctx.lineTo(path[i].x, path[i].y);
			//     }
			//     ctx.stroke();
			// });

			// ellipses.forEach(ellipse => {
			//     drawEllipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, ellipse.color, ellipse.strokeWidth);
			// });
		}

		// 绘制圆
		function drawEllipse(x, y, radiusX, radiusY, color, strokeWidth) {
			ctx.lineWidth = strokeWidth || 2;
			ctx.strokeStyle = color || 'black';
			ctx.beginPath();
			ctx.ellipse(x, y, radiusX, radiusY, 0, 0, Math.PI * 2);
			ctx.stroke();
		}

		// 检测点击是否在圆/椭圆内
		function isPointInEllipse(x, y, ellipse) {
			const dx = x - ellipse.x;
			const dy = y - ellipse.y;
			return (
				(dx * dx) / (ellipse.radiusX * ellipse.radiusX) +
				(dy * dy) / (ellipse.radiusY * ellipse.radiusY) <=
				1
			);
		}

		function handleCircle(x, y) { }
		

		function handleDownload() {
			mergedCanvas = document.createElement('canvas');
			mergedCanvas.width = canvasWidth;
			mergedCanvas.height = canvasHeight;
			const mergeCtx = mergedCanvas.getContext('2d');

			mergeCtx.drawImage(canvas2, 0, 0);

			mergeCtx.drawImage(canvas, 0, 0);
			document.body.appendChild(mergedCanvas);

			// 导出合并后的canvas为图片
			mergedCanvas.toBlob((blob) => {
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'merged_image.png'; // 可以指定文件名
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url); // 释放URL对象
			});
		}
	</script>
</body>

</html>