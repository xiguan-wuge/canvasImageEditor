<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Text Edit</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 1px solid black;
        }
        #textInput {
            position: absolute;
            display: none;
            border: 1px solid #000;
            background: rgba(255, 255, 255, 0.8);
            outline: none;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <input type="text" id="textInput">

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const textInput = document.getElementById('textInput');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let texts = [];
        let isEditing = false;
        let editingIndex = null;
        let dragIndex = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let isDragging = false;
        let mouseDownTime = 0; // 记录鼠标按下的时间

        // 处理鼠标按下事件
        canvas.addEventListener('mousedown', (e) => {
            mouseDownTime = Date.now(); // 记录按下时间

            const { offsetX, offsetY } = e;

            // 检查是否点击了已有文本
            const textIndex = texts.findIndex(text => {
                const width = ctx.measureText(text.value).width;
                return offsetX >= text.x && offsetX <= text.x + width && offsetY >= text.y - 16 && offsetY <= text.y;
            });

            if (textIndex !== -1) {
                // 如果点击了已有文本，进入拖动模式
                dragIndex = textIndex;
                dragOffsetX = offsetX - texts[dragIndex].x;
                dragOffsetY = offsetY - texts[dragIndex].y;
                canvas.style.cursor = 'move';
                isDragging = true;
            } else if (!isEditing) {
                // 如果点击了空白区域且当前不在编辑状态，则进入编辑模式
                textInput.style.left = `${offsetX}px`;
                textInput.style.top = `${offsetY - 16}px`;
                textInput.value = '';
                textInput.style.display = 'block';
                textInput.focus();
                texts.push({ x: offsetX, y: offsetY, value: '' });
                editingIndex = texts.length - 1;
                isEditing = true;
            }
        });

        // 处理鼠标移动事件，用于拖动文本
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && dragIndex !== null) {
                const { offsetX, offsetY } = e;
                texts[dragIndex].x = offsetX - dragOffsetX;
                texts[dragIndex].y = offsetY - dragOffsetY;
                drawTexts();
            }
        });

        // 处理鼠标释放事件，结束拖动或编辑状态
        canvas.addEventListener('mouseup', (e) => {
            const mouseUpTime = Date.now(); // 记录释放时间

            if (isDragging && dragIndex !== null) {
                // 如果结束拖动，则停止拖动状态
                dragIndex = null;
                isDragging = false;
                canvas.style.cursor = 'default';
            } else if (isEditing && editingIndex !== null) {
                // 如果没有拖动且是在编辑状态下，检查点击时间
                const totalTime = mouseUpTime - mouseDownTime
                console.log('totalTime', totalTime);
                if (totalTime < 300) { // 判断点击时间小于200ms为点击事件
                    texts[editingIndex].value = textInput.value;
                    textInput.style.display = 'none';
                    isEditing = false;
                    editingIndex = null;
                    drawTexts();
                }
            }
        });

        // 绘制所有文本
        function drawTexts() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            texts.forEach(text => {
                ctx.font = '16px Arial';
                ctx.fillText(text.value, text.x, text.y);
            });
        }

    </script>
</body>
</html>
