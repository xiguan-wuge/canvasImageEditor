<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Text Input and Editing</title>
    <style>
        canvas {
            border: 1px solid black;
            cursor: text;
        }
        #textInput {
            position: absolute;
            display: none;
            border: 1px solid gray;
            padding: 2px;
        }
        #controls {
            margin-bottom: 10px;
        }
        #controls input, #controls select {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="fontSize">Font Size:</label>
        <input type="number" id="fontSize" value="20" min="10" max="100">

        <label for="fontColor">Font Color:</label>
        <input type="color" id="fontColor" value="#000000">

        <label for="fontFamily">Font Family:</label>
        <select id="fontFamily">
            <option value="Arial">Arial</option>
            <option value="Verdana">Verdana</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Courier New">Courier New</option>
            <option value="Georgia">Georgia</option>
        </select>
    </div>

    <canvas id="myCanvas" width="800" height="600"></canvas>
    <input type="text" id="textInput">

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const textInput = document.getElementById('textInput');

        const fontSizeInput = document.getElementById('fontSize');
        const fontColorInput = document.getElementById('fontColor');
        const fontFamilyInput = document.getElementById('fontFamily');

        let isEditingText = false;
        let isDraggingText = false;
        let currentTextPosition = { x: 0, y: 0 };
        let selectedText = null;

        let texts = []; // 存储所有的文本对象

        // 处理点击事件，用于设置文本输入位置或选择已有文本
        canvas.addEventListener('click', (e) => {
            if (isDraggingText) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            selectedText = getTextAtPosition(x, y);

            if (selectedText) {
                // 开始拖动文本
                isDraggingText = true;
                currentTextPosition.x = x;
                currentTextPosition.y = y;
            } else {
                // 进行新的文本输入
                currentTextPosition.x = x;
                currentTextPosition.y = y;

                textInput.style.left = `${x + rect.left}px`;
                textInput.style.top = `${y + rect.top}px`;
                textInput.style.display = 'block';
                textInput.value = '';
                textInput.focus();

                isEditingText = true;
            }
        });

        // 处理输入框失去焦点事件，将文本绘制到 Canvas 上
        textInput.addEventListener('blur', () => {
            if (isEditingText) {
                const text = textInput.value;
                if (text) {
                    const fontSize = fontSizeInput.value;
                    const fontColor = fontColorInput.value;
                    const fontFamily = fontFamilyInput.value;

                    const textObject = {
                        text: text,
                        x: currentTextPosition.x,
                        y: currentTextPosition.y,
                        fontSize: fontSize,
                        fontColor: fontColor,
                        fontFamily: fontFamily
                    };

                    texts.push(textObject);
                    drawText(textObject);
                }

                textInput.style.display = 'none';
                isEditingText = false;
            }
        });

        // 处理 Enter 键，完成文本输入
        textInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                textInput.blur();
            }
        });

        // 处理鼠标移动事件，用于拖动文本
        canvas.addEventListener('mousemove', (e) => {
            if (isDraggingText && selectedText) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                selectedText.x += x - currentTextPosition.x;
                selectedText.y += y - currentTextPosition.y;

                currentTextPosition.x = x;
                currentTextPosition.y = y;

                redrawCanvas();
            }
        });

        // 处理鼠标松开事件，结束拖动
        canvas.addEventListener('mouseup', () => {
            isDraggingText = false;
            selectedText = null;
        });

        function drawText(textObject) {
            ctx.font = `${textObject.fontSize}px ${textObject.fontFamily}`;
            ctx.fillStyle = textObject.fontColor;
            ctx.fillText(textObject.text, textObject.x, textObject.y);
        }

        function getTextAtPosition(x, y) {
            // 从后往前遍历，找到最上面的文本
            for (let i = texts.length - 1; i >= 0; i--) {
                const textObject = texts[i];
                const textWidth = ctx.measureText(textObject.text).width;
                const textHeight = textObject.fontSize; // 大致的高度估计

                if (
                    x >= textObject.x && x <= textObject.x + textWidth &&
                    y <= textObject.y && y >= textObject.y - textHeight
                ) {
                    return textObject;
                }
            }
            return null;
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            texts.forEach(drawText);
        }
    </script>
</body>
</html>
