<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Mosaic Effect with Mouse Interaction</title>
    <style>
        #mosaicCanvas {
            border: 1px solid black;
            cursor: crosshair;
        }
    </style>
</head>
<body>
<canvas id="mosaicCanvas" width="800" height="600"></canvas>
<script>
    const imageSrc = 'https://cdn.pixabay.com/photo/2024/01/02/10/33/stream-8482939_1280.jpg'; // 替换为你要使用的图片路径
    const blockSize = 20; // 每个马赛克块的大小

    const canvas = document.getElementById('mosaicCanvas');
    const ctx = canvas.getContext('2d');
    let isMouseDown = false; // 标记鼠标是否按下

    const img = new Image();
    img.crossOrigin = "Anonymous"; // 允许跨域访问（如果图片来自不同源）
    img.src = imageSrc;

    // 图片加载完成后，将其绘制到画布上
    img.onload = function() {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };

    /**
     * applyMosaicAt
     * 在指定的(x, y)位置应用马赛克效果
     *
     * @param {number} x - 应用马赛克的中心X坐标
     * @param {number} y - 应用马赛克的中心Y坐标
     */
    function applyMosaicAt(x, y) {
        // 计算马赛克块的起始坐标（确保不会超出画布边界）
        const startX = Math.max(0, x - blockSize / 2);
        const startY = Math.max(0, y - blockSize / 2);
        const width = Math.min(blockSize, canvas.width - startX);
        const height = Math.min(blockSize, canvas.height - startY);

        // 获取指定区域的像素数据
        const imageData = ctx.getImageData(startX, startY, width, height);
        const data = imageData.data;

        let red = 0, green = 0, blue = 0;
        let pixelCount = 0;

        // 计算选定区域内所有像素的平均颜色值
        for (let row = 0; row < height; row++) {
            for (let col = 0; col < width; col++) {
                const index = (row * width + col) * 4;
                red += data[index];
                green += data[index + 1];
                blue += data[index + 2];
                pixelCount++;
            }
        }

        // 平均颜色值
        red = Math.floor(red / pixelCount);
        green = Math.floor(green / pixelCount);
        blue = Math.floor(blue / pixelCount);

        // 将所有像素的颜色设置为平均值，实现马赛克效果
        for (let row = 0; row < height; row++) {
            for (let col = 0; col < width; col++) {
                const index = (row * width + col) * 4;
                data[index] = red;
                data[index + 1] = green;
                data[index + 2] = blue;
            }
        }

        // 将处理后的像素数据放回画布上
        ctx.putImageData(imageData, startX, startY);
    }

    // 当鼠标按下时，启用马赛克效果
    canvas.addEventListener('mousedown', function() {
        isMouseDown = true;
    });

    // 当鼠标移动时，检查是否需要应用马赛克效果
    canvas.addEventListener('mousemove', function(e) {
        if (isMouseDown) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            applyMosaicAt(mouseX, mouseY);
        }
    });

    // 当鼠标释放时，禁用马赛克效果
    canvas.addEventListener('mouseup', function() {
        isMouseDown = false;
    });

    // 当鼠标移出画布时，禁用马赛克效果
    canvas.addEventListener('mouseleave', function() {
        isMouseDown = false;
    });
</script>
</body>
</html>
