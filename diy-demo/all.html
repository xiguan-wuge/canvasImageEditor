<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Drawing App</title>
    <style>
      #toolbar {
        margin-bottom: 10px;
      }
      #mosaicCanvas {
        border: 1px solid black;
        cursor: crosshair;
      }
      .button {
        margin-right: 10px;
        padding: 5px 10px;
        cursor: pointer;
        background-color: lightgray;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      .button.active {
        background-color: #4caf50;
        color: white;
      }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <button class="button" id="drawArrowBtn">画箭头</button>
      <button class="button" id="mosaicBtn">添加马赛克</button>
      <button class="button" id="undoBtn">撤销</button>
      <button class="button" id="redoBtn">取消撤销</button>
    </div>

    <canvas id="mosaicCanvas" width="800" height="600"></canvas>

    <script>
      const canvas = document.getElementById('mosaicCanvas');
      const ctx = canvas.getContext('2d');

      let isDrawing = false;
      let startX, startY;
      let currentTool = 'arrow'; // 默认工具为画箭头
      const actions = []; // 用于存储操作的历史记录
      let undoStack = []; // 用于存储撤销的操作

      const imageSrc = 'https://cdn.pixabay.com/photo/2024/01/02/10/33/stream-8482939_1280.jpg'; // 替换为你要使用的图片路径
      const img = new Image();
      img.crossOrigin = 'Anonymous'; // 允许跨域访问
      img.src = imageSrc;

      img.onload = function () {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        saveAction(); // 保存初始状态
      };

      // 设置工具按钮
      const arrowButton = document.getElementById('drawArrowBtn');
      const mosaicButton = document.getElementById('mosaicBtn');
      const undoButton = document.getElementById('undoBtn');
      const redoButton = document.getElementById('redoBtn');

      arrowButton.addEventListener('click', () => setTool('arrow'));
      mosaicButton.addEventListener('click', () => setTool('mosaic'));
      undoButton.addEventListener('click', undo);
      redoButton.addEventListener('click', redo);

      function setTool(tool) {
        currentTool = tool;
        arrowButton.classList.toggle('active', tool === 'arrow');
        mosaicButton.classList.toggle('active', tool === 'mosaic');
      }

      function saveAction() {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        actions.push(imageData);
        undoStack = []; // 每次新的操作会清空撤销栈
      }

      function undo() {
        if (actions.length > 1) {
          const lastAction = actions.pop();
          undoStack.push(lastAction);
          ctx.putImageData(actions[actions.length - 1], 0, 0);
        }
      }

      function redo() {
        if (undoStack.length > 0) {
          const redoAction = undoStack.pop();
          actions.push(redoAction);
          ctx.putImageData(redoAction, 0, 0);
        }
      }

      canvas.addEventListener('mousedown', function (e) {
        isDrawing = true;
        startX = e.offsetX;
        startY = e.offsetY;
      });

      canvas.addEventListener('mousemove', function (e) {
        if (!isDrawing) return;

        const currentX = e.offsetX;
        const currentY = e.offsetY;

        if (currentTool === 'arrow') {
          drawArrow2(startX, startY, currentX, currentY);
          // drawGradientArrow(startX, startY, currentX, currentY)
        } else if (currentTool === 'mosaic') {
          applyMosaicAt(currentX, currentY);
        }
      });

      canvas.addEventListener('mouseup', function () {
        if (isDrawing) {
          isDrawing = false;
          saveAction(); // 保存当前操作
        }
      });

      canvas.addEventListener('mouseleave', function () {
        if (isDrawing) {
          isDrawing = false;
          saveAction(); // 保存当前操作
        }
      });

      function drawArrow(x1, y1, x2, y2) {
        ctx.putImageData(actions[actions.length - 1], 0, 0); // 恢复上次绘制的图像

        const headlen = 10; // 箭头头部的长度
        const angle = Math.atan2(y2 - y1, x2 - x1);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(
          x2 - headlen * Math.cos(angle - Math.PI / 6),
          y2 - headlen * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          x2 - headlen * Math.cos(angle + Math.PI / 6),
          y2 - headlen * Math.sin(angle + Math.PI / 6)
        );
        ctx.lineTo(x2, y2);
        ctx.lineTo(
          x2 - headlen * Math.cos(angle - Math.PI / 6),
          y2 - headlen * Math.sin(angle - Math.PI / 6)
        );
        ctx.strokeStyle = 'red';
        ctx.stroke();
        ctx.fillStyle = 'red';
        ctx.fill();
      }
      function drawArrow2(x1, y1, x2, y2) {
        // 清除并恢复上次绘制的图像
        ctx.putImageData(actions[actions.length - 1], 0, 0);

        // 箭头头部的长度
        const headlen = 10;
        const angle = Math.atan2(y2 - y1, x2 - x1);

        // 计算距离
        const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

        // 线条的最大宽度
        const maxLineWidth = 10;

        // 逐段绘制线条，使其逐渐变粗
        for (let i = 0; i < distance; i++) {
          const t = i / distance;
          const lineWidth = 1 + t * (maxLineWidth - 1); // 线条宽度从1逐渐增至maxLineWidth
          const xPos = x1 + t * (x2 - x1);
          const yPos = y1 + t * (y2 - y1);

          ctx.beginPath();
          ctx.moveTo(xPos, yPos);
          ctx.lineTo(xPos + 1, yPos + 1); // 绘制短小的线段
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = 'red';
          ctx.stroke();
        }

        // 绘制箭头头部
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(
          x2 - headlen * Math.cos(angle - Math.PI / 6),
          y2 - headlen * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          x2 - headlen * Math.cos(angle + Math.PI / 6),
          y2 - headlen * Math.sin(angle + Math.PI / 6)
        );
        ctx.lineTo(x2, y2);
        ctx.lineTo(
          x2 - headlen * Math.cos(angle - Math.PI / 6),
          y2 - headlen * Math.sin(angle - Math.PI / 6)
        );
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 1; // 箭头头部的线宽可以保持统一
        ctx.stroke();
        ctx.fillStyle = 'red';
        ctx.fill();
      }

      // 绘制渐变线条的箭头
      function drawGradientArrow(fromX, fromY, toX, toY, startWidth = 1, endWidth = 8) {
        const steps = 300; // 分段数量
        const dx = (toX - fromX) / steps;
        const dy = (toY - fromY) / steps;

        ctx.lineCap = 'round'; // 设置线条端点为圆形

        for (let i = 0; i < steps; i++) {
          const x1 = fromX + i * dx;
          const y1 = fromY + i * dy;
          const x2 = fromX + (i + 1) * dx;
          const y2 = fromY + (i + 1) * dy;

          const lineWidth = startWidth + (endWidth - startWidth) * (i / steps);

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.strokeStyle = '#FF0000';
          ctx.lineWidth = lineWidth;
          ctx.stroke();
        }

        const angle = Math.atan2(toY - fromY, toX - fromX);
        const headLength = endWidth * 2;

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(
          toX - headLength * Math.cos(angle - Math.PI / 6),
          toY - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          toX - headLength * Math.cos(angle + Math.PI / 6),
          toY - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.lineTo(toX, toY);
        ctx.lineTo(
          toX - headLength * Math.cos(angle - Math.PI / 6),
          toY - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = endWidth;
        ctx.stroke();
        ctx.fillStyle = '#FF0000';
        ctx.fill();
      }

      function applyMosaicAt(x, y) {
        const blockSize = 20; // 马赛克块大小

        const startX = Math.max(0, x - blockSize / 2);
        const startY = Math.max(0, y - blockSize / 2);
        const width = Math.min(blockSize, canvas.width - startX);
        const height = Math.min(blockSize, canvas.height - startY);

        const imageData = ctx.getImageData(startX, startY, width, height);
        const data = imageData.data;

        let red = 0,
          green = 0,
          blue = 0;
        let pixelCount = 0;

        for (let row = 0; row < height; row++) {
          for (let col = 0; col < width; col++) {
            const index = (row * width + col) * 4;
            red += data[index];
            green += data[index + 1];
            blue += data[index + 2];
            pixelCount++;
          }
        }

        red = Math.floor(red / pixelCount);
        green = Math.floor(green / pixelCount);
        blue = Math.floor(blue / pixelCount);

        for (let row = 0; row < height; row++) {
          for (let col = 0; col < width; col++) {
            const index = (row * width + col) * 4;
            data[index] = red;
            data[index + 1] = green;
            data[index + 2] = blue;
          }
        }

        ctx.putImageData(imageData, startX, startY);
      }
    </script>
  </body>
</html>
